#!/usr/bin/env python3

# (c) 2020 Simon Meggle <simon.meggle@elabit.de>

# This file is part of RobotMK
# https://robotmk.org
# https://github.com/simonmeggle/robotmk

# RobotMK is free software;  you can redistribute it and/or modify it
# under the  terms of the  GNU General Public License  as published by
# the Free Software Foundation in version 3.  This file is distributed
# in the hope that it will be useful, but WITHOUT ANY WARRANTY;  with-
# out even the implied warranty of  MERCHANTABILITY  or  FITNESS FOR A
# PARTICULAR PURPOSE. See the  GNU General Public License for more de-
# ails.  You should have  received  a copy of the  GNU  General Public
# License along with GNU Make; see the file  COPYING.  If  not,  write
# to the Free Software Foundation, Inc., 51 Franklin St,  Fifth Floor,
# Boston, MA 02110-1301 USA.


import pywintypes, win32api, win32security
import win32con, winerror
from security_enums import TOKEN_GROUP_ATTRIBUTES, TOKEN_PRIVILEGE_ATTRIBUTES, \
     SECURITY_IMPERSONATION_LEVEL, TOKEN_TYPE, TOKEN_ELEVATION_TYPE


import os 
import sys
import shutil
from pathlib import Path
import logging

import ctypes
import win32api
import win32event
import win32process
import win32security
import win32ts
import win32con

import win32profile

DEFAULTS = {
   'nt': {
      'agent_data_dir'  : 'C:/ProgramData/checkmk/agent',
      'agent_cfg_dir'   : 'C:/ProgramData/checkmk/agent/config',
      #'outputdir'       : "str(Path(os.environ['TEMP']).joinpath('robot'))"
      'outputdir'       : "C:/Windows/temp",
      'logdir'       : "C:/Windows/temp",
   },
   'posix': {
      'agent_data_dir'  : '/usr/lib/check_mk_agent',
      'agent_cfg_dir'   : '/etc/check_mk',
      'outputdir'       : "str('/tmp/robot')"
   },
   'noarch': {
      'robotmk_yml'     : 'robotmk.yml',
      'enable_logging'  : True
   }
}



# outputdir = final path where all outputfiles, logfiles and report files ends.
# robotdir  = Location of Robot suite files/dirs
def start():
   setup_logging()
   print_banner()
   # Default config (+ overrides by env)
   env_cfg = get_env_config()
   robotmk_yml = env_cfg.pop('robotmk_yml')
   yml_cfg = read_yml(robotmk_yml, env_cfg)

   Path(yml_cfg['outputdir']).mkdir(exist_ok=True)
   robotdir = Path(yml_cfg.pop('robotdir', None))
   if not os.path.exists(robotdir):
      log_error(f"ERROR: {robotdir} does not exist; no suites found to execute. Exiting.")
      exit(1)

   #If no suites are defined we setup an empty suite dict.
   #This is necessary to later on fill the dict.
   if 'suites' in yml_cfg: 
      if not yml_cfg['suites']:
         yml_cfg['suites'] = {}
   else: 
      yml_cfg.setdefault('suites',{})
   if len(yml_cfg['suites']) == 0:
      log_info(f'No suites specified in configuration file -> run all in {robotdir}:')
      for suite in robotdir.iterdir():
         log_debug(suite.name)
         yml_cfg['suites'].update({suite.name:{}})

   for suite,suite_options in yml_cfg['suites'].items():
      log_info(f'--------- Robot suite: {robotdir.joinpath(suite)} ---------')
      #Lets test if the file or directory is available
      if not robotdir.joinpath(suite).exists():
         log_warning(f'Suite file or directory not found!')
         continue
      if suite_options is None or len(suite_options) == 0: 
         suite_options = {}
         log_info(f'No suite_options set; Starting with default suite_options')

      # Update the suite cfg with global cfg   
      suite_options = apply_global_cfg(suite, suite_options, yml_cfg)

      # Piggyback host
      if 'host' in suite_options:
         host = suite_options.pop('host')
         log_debug(f'Piggyback host: {host}')
      else:
         log_debug('NO piggyback host defined.')
      
      ######################## Run robot run..... ###############################################
      windows_options = suite_options.pop('windows', None)

      delegate_to_user_session = windows_options.get('delegate_to_user_session', False)
      if delegate_to_user_session and os.name != 'nt':
         log_warning('The delegation to a user session is only available/needed for Windows! Skipping this suite.')
         break

      if delegate_to_user_session: 
         log_debug(f'"delegate_to_user_session" is set => Suite {suite} will run in the session of the currently logged in user')
         # run robot via cmdline
         if 'variable' in suite_options: 
            variables = suite_options.pop('variable')
            # e.g. '--variable foovar1:foovalue1 --variable foovar2:foovalue2 --variable foovar3:foovalue3'
            variable_argstring = ' '.join(map(lambda x: f'--variable {x[0]}:{x[1]}', variables.items()))
         # e.g. '--console none --outputdir C:\\Windows\\temp --output rftest --log none --report none'
         options_argstring = ' '.join(list(map(lambda x: f'--{x[0]} {x[1]}' if x[1] != '' else f'--{x[0]} none', suite_options.items())))
         commandline = f'robot {options_argstring} {variable_argstring} {robotdir.joinpath(suite)}'
         
         rc = run_in_user_session(commandline)
      else:   
         # normal run, execute robot with Python run method
         # Preformat Variables to meet the Robot API requirement 
         # --variable name:value => ['name:value', 'name2:value2']
         log_debug('Test execution will be done in the context of cmk agent')
         if 'variable' in suite_options: 
            suite_options['variable'] = list(map(lambda x: f'{x[0]}:{x[1]}', suite_options['variable'].items()))
         log_debug(f'Start with following suite_options: {suite_options}')
         rc = run(robotdir.joinpath(suite), **suite_options)

      log_info(f'Robot suite {suite} finished with returncode: {rc}')
      if rc > 250: 
         log_error('Robot exited with error and no outputfile is generated.')
         log_error ('Please run robot command manually to see the error')
         break
      ######################## print output.xml to stdout #######################################
      if 'host' in locals():
         print(f'<<<<{host}>>>>')
      print('<<<robotmk:sep(0)>>>')
      robot_xml = Path(suite_options['outputdir']).joinpath(suite).with_suffix('.xml')
      try: 
         log_info(f'Reading result XML file {robot_xml}')
         with open (robot_xml, 'r') as f:
            shutil.copyfileobj(f, sys.stdout)
      except:
            log_error(f'Cannot find Robot XML file {robot_xml}!')
            exit(1)
      log_info('#######################################################################')

# returns the default config and overrides by env vars
def get_env_config():
   if os.name in ['nt', 'posix']:
      agent_data_dir = Path(os.environ.setdefault('AGENT_DATA_DIR', DEFAULTS[os.name]['agent_data_dir']))
      agent_cfg_dir  = Path(os.environ.setdefault('AGENT_CFG_DIR', DEFAULTS[os.name]['agent_cfg_dir']))
      outputdir =      Path(os.environ.setdefault('OUTPUTDIR', DEFAULTS[os.name]['outputdir']))
      env_cfg = {
         'outputdir'   : outputdir,
         'robotdir'    : agent_data_dir.joinpath('robot'),
         'robotmk_yml' : agent_cfg_dir.joinpath(DEFAULTS['noarch']['robotmk_yml']),
         'log'         : 'none',
         'console'     : 'none',
         'report'      : 'none',
         }
      log_debug('Configuration defined by environment variables: ')
      log_debug(env_cfg)
   else:
      # We are not on a supported OS
      log_error(f'OS Name {os.name} is not supported by robotmk')
      exit(1)
   return env_cfg

# Reads robotmk YML cfg file, updates and returns env cfg
# Main purpose is to read in the suites to execute; 
# can also override global settings
def read_yml(robotmk_yml, env_cfg):
   if os.access(robotmk_yml, os.R_OK):
      try:
         log_debug(f'Reading configuration file {robotmk_yml}')
         with open(robotmk_yml, 'r') as stream:   
            env_cfg.update(yaml.safe_load(stream))
      except yaml.YAMLError as exc:
         log_error("Error while parsing YAML file:")
         if hasattr(exc, 'problem_mark'):
            if exc.context != None:
               log_error('Parser says:\n\t' + str(exc.problem_mark) + '\n\t  ' +
                  str(exc.problem) + ' ' + str(exc.context) +
                  '\n\tPlease correct data and retry.')
            else:
               log_error('\t  parser says\n\t' + str(exc.problem_mark) + '\n\t  ' +
                  str(exc.problem) + '\n\tPlease correct data and retry.')
         exit(1)
   else:
      log_info('No configuration file {robot_cfg} found, starting with defaults')
   return env_cfg

def apply_global_cfg(suite, suite_options, yml_cfg): 
   # show Robot output on console while debugging
   if '--verbose' in sys.argv:
      suite_options.update({'console':'verbose'})
   else:
      suite_options.update({'console':'none'})
   
   suite_options.update({'outputdir': str(yml_cfg['outputdir'])})
   suite_options.update({'output': suite.replace('.robot','')})
   suite_options.setdefault('log',yml_cfg['log'])
   suite_options.setdefault('report',yml_cfg['report'])
   return suite_options

def setup_logging():
   if DEFAULTS['noarch']['enable_logging']:
      global logger
      logger = logging.getLogger('robotmk')
      logger.setLevel(logging.DEBUG)

      # File log
      fh = logging.FileHandler(Path(DEFAULTS['nt']['logdir'] ).joinpath('robotmk.log'))
      file_formatter = logging.Formatter(fmt='%(asctime)s %(levelname)s - %(message)s')
      fh.setFormatter(file_formatter)
      fh.setLevel(logging.DEBUG)
      logger.addHandler(fh)
      # stdout
      if '--verbose' in sys.argv: 
         console = logging.StreamHandler()
         console_formatter = logging.Formatter(fmt='%(asctime)s %(levelname)s - %(message)s')
         console.setFormatter(console_formatter)
         console.setLevel(logging.DEBUG)
         logger.addHandler(console)
      
      

def log_debug(text):
   logger.debug(text)

def log_info(text):
   logger.info(text)

def log_warning(text):
   logger.warning(text)

def log_error(text):
   logger.error(text)



def print_banner():
   log_info('')
   log_info('#######################################################################')
   log_info('###########################     RobotMK     ###########################')
   log_info('#######################################################################')
   log_info('               2020 Simon Meggle <simon.meggle@elabit.de> ')
   log_info('                      https://www.simon.meggle.de')
   log_info('')

def run_in_user_session(command_line):
   
   #"Run an application on the console of the current logged on console user."
   #This works only when run as a service using the standard service account LocalSystem
   # get the PID of service
   process = win32api.GetCurrentProcess()
   log_debug(f'service PID: {process}')

   # Gets the access token associated with the service process
   # TODO: Replace ALL_ACCESS by something smaller: https://docs.microsoft.com/en-us/windows/win32/secauthz/access-rights-for-access-token-objects
   processToken = win32security.OpenProcessToken(
      process,
      win32security.TOKEN_ALL_ACCESS)
   log_debug('service process token:' + str(processToken))
   log_debug('=== processToken vor Anpassung:')


   # https://stackoverflow.com/questions/44647066/python-windows-service-access-denied-when-calling-settokeninformation
   duplicate_token = win32security.DuplicateToken(processToken, 2)


   console_session_id = ctypes.windll.kernel32.WTSGetActiveConsoleSessionId()
   log_debug(f'WTSGetActiveConsoleSessionId: {console_session_id}') 


   def AdjustPriv(htoken, priv, enable=1):
      
      id = win32security.LookupPrivilegeValue(None,priv)
      if enable:
         newPriv = [(id, win32security.SE_PRIVILEGE_ENABLED)]
      else:
         newPriv = [(id,0)]
      win32security.AdjustTokenPrivileges(htoken, 0, newPriv)

   AdjustPriv(processToken, win32security.SE_TCB_NAME)
   AdjustPriv(processToken,win32security.SE_ASSIGNPRIMARYTOKEN_NAME)
   AdjustPriv(processToken,win32security.SE_INCREASE_QUOTA_NAME)










   
   # fixme
   #list_env()
   # Query the token of the user which is currently logged in
   try:
      log_debug(f'Quering the Token of the current user')
      console_user_token = win32ts.WTSQueryUserToken(console_session_id)
      log_debug('console_user_token: ' + console_user_token.__str__())
      #dump_token(console_user_token)
   except Exception as e: 
      if e.args[0] == 1314: 
         log_error("ERROR: Delegation of Robot tests to user session is only possible if the calling ")
         log_error(f"process runs with local SYSTEM user. Error 1314: {e.args[2]}")
      else:
         log_error("Unknown error occurred while delegating the test exeution to the current user session.")
      sys.exit(0)

   # TOKEN_ALL_ACCESS
   
    TOKEN_ASSIGN_PRIMARY
    TOKEN_DUPLICATE
    TOKEN_QUERY
    TOKEN_ADJUST_DEFAULT
    TOKEN_ADJUST_SESSIONID


   startupinfo = win32process.STARTUPINFO()
   startupinfo.dwFlags = win32process.STARTF_USESHOWWINDOW
   startupinfo.wShowWindow = win32con.SW_SHOW

   # winsta0 = WindowStation #1
   # default = Desktop #1 for user
   # https://www.codeproject.com/Articles/7666/Desktop-Switching
   
   # specifies either the name of the desktop or the name of both the desktop and window station for this process. A backslash in the string indicates that the string includes both the desktop and window station names. For CreateProcess() and CreateProcessAsUser(), if this member is NULL, the new process inherits the desktop and window station of its parent process. If this member is an empty string, the process does not inherit the desktop and window station of its parent process; instead, the system determines if a new desktop and window station need to be created. If the impersonated user already has a desktop, the system uses the existing desktop. ForCreateProcessWithLogonW(), if this member is NULL or an empty string, the new process inherits the desktop and window station of its parent process. It is the responsibility of the application to add permission for the specified user account to the inherited window station and desktop, even for WinSta0\Default. Windows Me/98/95:  Desktops and window stations are not supported.
   startupinfo.lpDesktop = 'winsta0\default'
   #startupinfo.lpDesktop = ''

   log_debug('Building process args')

   # Variante 1: geht grundsätzlich
   command_line = 'c:\\windows\\system32\\notepad.exe'
   env = os.environ
   creation_flags = 0
   CREATE_BREAKAWAY_FROM_JOB = 0x01000000
   creation_flags |= CREATE_BREAKAWAY_FROM_JOB
   #command_line = 'c:\\dummy.bat'
   createprocessArgs = (
      console_user_token,     # Token
      None,                   # Process name to be started (?)
      command_line,           # Full command line
      None,                   # Process security attributes
      None,                   # Thread security attributes
      0,                      # inherit parent handles
      creation_flags,         # dwCreationFlags
      env,                    # environment; None = inherit
      None,                   # currentDir
      startupinfo)            # STARTUPINFO object that specifies how the main window for the new process should appear.

   log_debug('CreateProcessAsUser - now starting Robot test in the user context')
   # fixme
   log_debug(f'Starting: {command_line}')
   try:
      proc_handle, thread_id ,pid, tid = win32process.CreateProcessAsUser(*createprocessArgs)
   except Exception as e:
       log_error(e)

   # ---

   # # Variante 2: geht grundsätzlich 
   # appname = None
   # cmdline = 'C:\Windows\System32\cmd.exe'
   # cflags = win32con.NORMAL_PRIORITY_CLASS | win32con.CREATE_NEW_CONSOLE
   # profileDir = win32profile.GetUserProfileDirectory(console_user_token) # Needed to avoid error 0x0000142
   # environment = win32profile.CreateEnvironmentBlock(console_user_token, False)
   # startup_info = win32process.STARTUPINFO()
   # try:
   #    proc_handle, thread_id ,pid, tid = win32process.CreateProcessAsUser(console_user_token, appname, cmdline, None, None, True, cflags, environment, profileDir, startup_info)
   # except Exception as e:
   #    log_error(e)


   log_debug('PID: ' + str(pid))
   log_debug('Waiting for Robot to finish...')
   # TODO: How long do we want to wait? 
   win32event.WaitForSingleObject(proc_handle, win32event.INFINITE)
   rc = win32process.GetExitCodeProcess(proc_handle)
   return(rc)

def list_env():
   log_debug('FOO======0')   
   for k, v in sorted(os.environ.items()):
      text = k+' : '+v
      log_debug(text)
   # list elements in path environment variable
   [log_debug(item) for item in os.environ['PATH'].split(';')]


def log_debug_list(*texts):
   logger.debug(', '.join([str(t) for t in texts]))


# """ Lists various types of information about current user's access token,
#     including UAC status on Vista
# """


# def dump_token(th):
#     token_type=win32security.GetTokenInformation(th, win32security.TokenType)
#     log_debug_list('TokenType:', token_type, TOKEN_TYPE.lookup_name(token_type))
#     if token_type==win32security.TokenImpersonation:
#         imp_lvl=win32security.GetTokenInformation(th, win32security.TokenImpersonationLevel)
#         log_debug_list('TokenImpersonationLevel:', imp_lvl, SECURITY_IMPERSONATION_LEVEL.lookup_name(imp_lvl))

#     log_debug_list('TokenSessionId:', win32security.GetTokenInformation(th, win32security.TokenSessionId))

#     privs=win32security.GetTokenInformation(th,win32security.TokenPrivileges)
#     log_debug_list('TokenPrivileges:')
#     for priv_luid, priv_flags in privs:
#         flag_names, unk=TOKEN_PRIVILEGE_ATTRIBUTES.lookup_flags(priv_flags)
#         flag_desc = ' '.join(flag_names)
#         if (unk):
#             flag_desc += '(' + str(unk) + ')'

#         priv_name=win32security.LookupPrivilegeName('',priv_luid)
#         priv_desc=win32security.LookupPrivilegeDisplayName('',priv_name)
#         log_debug_list('\t', priv_name, priv_desc, priv_flags, flag_desc)

#     log_debug_list('TokenGroups:')
#     groups=win32security.GetTokenInformation(th,win32security.TokenGroups)
#     for group_sid, group_attr in groups:
#         flag_names, unk=TOKEN_GROUP_ATTRIBUTES.lookup_flags(group_attr)
#         flag_desc = ' '.join(flag_names)
#         if (unk):
#             flag_desc += '(' + str(unk) + ')'
#         if group_attr & TOKEN_GROUP_ATTRIBUTES.SE_GROUP_LOGON_ID:
#             sid_desc = 'Logon sid'
#         else:
#             sid_desc=win32security.LookupAccountSid('',group_sid)
#         log_debug_list('\t',group_sid, sid_desc, group_attr, flag_desc)

#     ## Vista token information types, will throw (87, 'GetTokenInformation', 'The parameter is incorrect.') on earier OS
#     try:
#         is_elevated=win32security.GetTokenInformation(th, win32security.TokenElevation)
#         log_debug_list('TokenElevation:', is_elevated)
#     except pywintypes.error as details:
#         if details.winerror != winerror.ERROR_INVALID_PARAMETER:
#             raise
#         return None
#     log_debug_list('TokenHasRestrictions:', win32security.GetTokenInformation(th, win32security.TokenHasRestrictions))
#     log_debug_list('TokenMandatoryPolicy', win32security.GetTokenInformation(th, win32security.TokenMandatoryPolicy))   
#     log_debug_list('TokenVirtualizationAllowed:', win32security.GetTokenInformation(th, win32security.TokenVirtualizationAllowed))
#     log_debug_list('TokenVirtualizationEnabled:', win32security.GetTokenInformation(th, win32security.TokenVirtualizationEnabled))

#     elevation_type = win32security.GetTokenInformation(th, win32security.TokenElevationType)        
#     log_debug_list('TokenElevationType:', elevation_type, TOKEN_ELEVATION_TYPE.lookup_name(elevation_type))
#     if elevation_type!=win32security.TokenElevationTypeDefault:
#         lt=win32security.GetTokenInformation(th, win32security.TokenLinkedToken)
#         log_debug_list('TokenLinkedToken:', lt)
#     else:
#         lt=None
#     return lt




if __name__ == '__main__': 
   try:
      import yaml
   except:
      log_debug('You need pyYAML installed to run this plugin.')
      exit(1)
   try:
      from robot import run
   except:
      log_debug('You need robotframework installed to run this plugin.')
      exit(1)
   start()
